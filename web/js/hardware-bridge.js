/**
 * Hardware Detection Bridge
 * 
 * This module bridges the web interface with the real hardware detection CLI tools
 * (lx-hw-detect, lx-hw-detect-gtk, lx-hw-detect-qt6) to provide actual hardware data
 * instead of browser-based simulation.
 * 
 * Integration modes:
 * 1. WebAssembly Integration (future): Direct Rust code execution in browser
 * 2. Local CLI Integration: Execute local CLI tools via browser APIs
 * 3. Upload Integration: Upload hardware reports generated by CLI tools
 * 4. Server Integration: Connect to local hardware detection server
 */

class HardwareBridge {
    constructor() {
        this.detectionMethods = {
            'upload': {
                name: 'üì§ Upload Hardware Report',
                description: 'Upload a hardware report generated by lx-hw-detect CLI tool',
                available: true,
                priority: 1
            },
            'local-server': {
                name: 'üñ•Ô∏è Local Detection Server',
                description: 'Connect to local lx-hw-detect server (experimental)',
                available: this.checkLocalServer(),
                priority: 2
            },
            'cli-integration': {
                name: '‚ö° Direct CLI Integration',
                description: 'Execute lx-hw-detect CLI tool directly (requires permissions)',
                available: this.checkCliIntegration(),
                priority: 3
            },
            'browser-fallback': {
                name: 'üåê Browser-Based Detection',
                description: 'Fallback browser detection using web APIs',
                available: true,
                priority: 4
            }
        };
        
        this.init();
    }
    
    init() {
        this.createBridgeUI();
        this.setupEventListeners();
        this.checkAvailableMethods();
    }
    
    /**
     * Create the hardware bridge UI component
     */
    createBridgeUI() {
        const bridgeContainer = document.createElement('div');
        bridgeContainer.className = 'hardware-bridge-container';
        bridgeContainer.innerHTML = `
            <div class="bridge-header">
                <h3>üîß Hardware Detection Methods</h3>
                <p>Choose your preferred method for hardware detection:</p>
            </div>
            
            <div class="detection-methods">
                ${this.renderDetectionMethods()}
            </div>
            
            <div class="bridge-status">
                <div id="detection-status" class="status-message">
                    Ready for hardware detection
                </div>
                <div id="detection-progress" class="progress-bar" style="display: none;">
                    <div class="progress-fill"></div>
                </div>
            </div>
            
            <div class="bridge-results">
                <div id="hardware-results" class="hardware-results-container"></div>
            </div>
        `;
        
        // Insert into existing configuration engine or create standalone
        const configEngine = document.querySelector('.config-engine-container');
        if (configEngine) {
            configEngine.prepend(bridgeContainer);
        } else {
            // Create standalone bridge interface
            const bridgeSection = document.createElement('section');
            bridgeSection.id = 'hardware-bridge';
            bridgeSection.className = 'bridge-section';
            bridgeSection.appendChild(bridgeContainer);
            
            // Insert after search section
            const searchSection = document.getElementById('search');
            if (searchSection) {
                searchSection.parentNode.insertBefore(bridgeSection, searchSection.nextSibling);
            }
        }
    }
    
    /**
     * Render detection method options
     */
    renderDetectionMethods() {
        return Object.entries(this.detectionMethods)
            .sort((a, b) => a[1].priority - b[1].priority)
            .map(([method, config]) => `
                <div class="detection-method ${config.available ? 'available' : 'unavailable'}" 
                     data-method="${method}">
                    <div class="method-header">
                        <h4>${config.name}</h4>
                        <span class="availability-badge ${config.available ? 'available' : 'unavailable'}">
                            ${config.available ? '‚úÖ Available' : '‚ùå Unavailable'}
                        </span>
                    </div>
                    <p>${config.description}</p>
                    ${config.available ? `
                        <button class="detection-button" data-method="${method}">
                            Use This Method
                        </button>
                    ` : ''}
                    ${this.renderMethodSpecificUI(method, config)}
                </div>
            `).join('');
    }
    
    /**
     * Render method-specific UI elements
     */
    renderMethodSpecificUI(method, config) {
        switch (method) {
            case 'upload':
                return `
                    <div class="method-ui upload-ui" style="display: none;">
                        <div class="file-upload-area">
                            <input type="file" id="hardware-file-input" accept=".json,.yaml,.yml" style="display: none;">
                            <div class="upload-dropzone" onclick="document.getElementById('hardware-file-input').click();">
                                <div class="upload-icon">üìÅ</div>
                                <p>Click to select hardware report file</p>
                                <p class="upload-hint">Supports JSON and YAML formats from lx-hw-detect</p>
                            </div>
                        </div>
                        <div class="upload-instructions">
                            <h5>üìñ How to generate a hardware report:</h5>
                            <div class="command-examples">
                                <code>lx-hw-detect --output my-hardware.json --privacy basic</code>
                                <code>lx-hw-detect-gtk</code> (export from GUI)
                                <code>lx-hw-detect-qt6</code> (export from GUI)
                            </div>
                        </div>
                    </div>
                `;
                
            case 'local-server':
                return `
                    <div class="method-ui server-ui" style="display: none;">
                        <div class="server-connection">
                            <label>Server URL:</label>
                            <input type="url" id="server-url" value="http://localhost:8080" placeholder="http://localhost:8080">
                            <button class="test-connection-btn">Test Connection</button>
                        </div>
                        <div class="server-instructions">
                            <h5>üöÄ Start hardware detection server:</h5>
                            <code>lx-hw-detect server --bind 127.0.0.1:8080</code>
                        </div>
                    </div>
                `;
                
            case 'cli-integration':
                return `
                    <div class="method-ui cli-ui" style="display: none;">
                        <div class="cli-integration-panel">
                            <div class="cli-tools-status">
                                <h5>üîß Available CLI Tools</h5>
                                <div class="tool-status-grid">
                                    <div class="tool-status">
                                        <span class="tool-icon">‚ö°</span>
                                        <span class="tool-name">lx-hw-detect</span>
                                        <span class="tool-description">Fast CLI detection with 39+ devices</span>
                                    </div>
                                    <div class="tool-status">
                                        <span class="tool-icon">üñºÔ∏è</span>
                                        <span class="tool-name">lx-hw-detect-gtk</span>
                                        <span class="tool-description">GTK4 GUI with Adwaita theme</span>
                                    </div>
                                    <div class="tool-status">
                                        <span class="tool-icon">üé®</span>
                                        <span class="tool-name">lx-hw-detect-qt6</span>
                                        <span class="tool-description">Qt6 QML with Gruvbox theme</span>
                                    </div>
                                </div>
                            </div>
                            
                            <div class="cli-options">
                                <div class="privacy-selection">
                                    <label>Privacy Level:</label>
                                    <select id="privacy-level">
                                        <option value="basic">Basic (24h salt rotation)</option>
                                        <option value="enhanced">Enhanced (12h salt rotation)</option>
                                        <option value="strict">Strict (1h salt rotation)</option>
                                    </select>
                                </div>
                                <div class="output-format">
                                    <label>Output Format:</label>
                                    <select id="output-format">
                                        <option value="json">JSON</option>
                                        <option value="yaml">YAML</option>
                                    </select>
                                </div>
                            </div>
                            
                            <div class="cli-launch-options">
                                <h5>üöÄ Launch Detection Commands</h5>
                                <div class="command-grid">
                                    <div class="command-option">
                                        <strong>CLI Tool (Fastest - Real Hardware Detection)</strong>
                                        <code class="command-text">cargo run --bin lx-hw-detect export --format json --privacy basic</code>
                                        <button class="copy-command-btn" data-command="cargo run --bin lx-hw-detect export --format json --privacy basic">üìã Copy</button>
                                    </div>
                                    <div class="command-option">
                                        <strong>GTK4 GUI (User-Friendly Interface)</strong>
                                        <code class="command-text">cargo run --features=&quot;gtk-gui&quot; --bin lx-hw-detect-gtk</code>
                                        <button class="copy-command-btn" data-command='cargo run --features="gtk-gui" --bin lx-hw-detect-gtk'>üìã Copy</button>
                                    </div>
                                    <div class="command-option">
                                        <strong>Qt6 GUI (Modern Gruvbox Interface)</strong>
                                        <code class="command-text">cargo run --features=&quot;qt6-gui&quot; --bin lx-hw-detect-qt6</code>
                                        <button class="copy-command-btn" data-command='cargo run --features="qt6-gui" --bin lx-hw-detect-qt6'>üìã Copy</button>
                                    </div>
                                </div>
                                
                                <div class="integration-workflow">
                                    <h5>üí° Integration Workflow</h5>
                                    <ol>
                                        <li>Run any command above in your terminal</li>
                                        <li>For GUI tools: Use the export function to save your report</li>
                                        <li>For CLI tool: Report is automatically saved</li>
                                        <li>Upload the generated report using "Upload Hardware Report" method</li>
                                    </ol>
                                </div>
                                
                                <div class="github-integration">
                                    <h5>üêô GitHub Community Integration</h5>
                                    <p>Contribute your hardware data to the Linux Hardware Database:</p>
                                    <div class="github-actions">
                                        <button class="github-action-btn" id="submit-github-issue" disabled>
                                            üìù Submit GitHub Issue
                                        </button>
                                        <button class="github-action-btn" id="create-pull-request" disabled>
                                            üîÄ Create Pull Request  
                                        </button>
                                        <button class="github-action-btn github-login-btn" id="github-auth-btn">
                                            üîê Login to GitHub
                                        </button>
                                    </div>
                                    <div class="github-status">
                                        <span id="github-user-status">üîí GitHub authentication required for community contributions</span>
                                    </div>
                                    <div class="github-help">
                                        <small>üí° GitHub integration allows you to contribute hardware reports directly to the community database via issues or pull requests.</small>
                                    </div>
                                </div>
                            </div>
                        </div>
                    </div>
                `;
                
            default:
                return '';
        }
    }
    
    /**
     * Set up event listeners for bridge interface
     */
    setupEventListeners() {
        document.addEventListener('click', (e) => {
            if (e.target.classList.contains('detection-button')) {
                const method = e.target.dataset.method;
                this.selectDetectionMethod(method);
            }
            
            if (e.target.classList.contains('test-connection-btn')) {
                this.testServerConnection();
            }
            
            if (e.target.classList.contains('copy-command-btn')) {
                const command = e.target.dataset.command;
                this.copyCommandToClipboard(command, e.target);
            }
            
            if (e.target.id === 'github-auth-btn') {
                this.authenticateWithGitHub();
            }
            
            if (e.target.id === 'submit-github-issue') {
                this.submitGitHubIssue();
            }
            
            if (e.target.id === 'create-pull-request') {
                this.createGitHubPullRequest();
            }
        });
        
        document.addEventListener('change', (e) => {
            if (e.target.id === 'hardware-file-input') {
                this.handleFileUpload(e.target.files[0]);
            }
        });
        
        // Drag and drop support for file upload
        this.setupDragAndDrop();
    }
    
    /**
     * Select and activate a detection method
     */
    selectDetectionMethod(method) {
        // Hide all method UIs
        document.querySelectorAll('.method-ui').forEach(ui => {
            ui.style.display = 'none';
        });
        
        // Show selected method UI
        const selectedUI = document.querySelector(`.${method}-ui`);
        if (selectedUI) {
            selectedUI.style.display = 'block';
        }
        
        // Update status
        this.updateStatus(`Selected: ${this.detectionMethods[method].name}`, 'info');
    }
    
    /**
     * Handle hardware report file upload
     */
    async handleFileUpload(file) {
        if (!file) return;
        
        this.updateStatus('üì§ Processing uploaded file...', 'loading');
        
        try {
            const text = await file.text();
            let hardwareData;
            
            // Parse based on file extension
            if (file.name.endsWith('.json')) {
                hardwareData = JSON.parse(text);
            } else if (file.name.endsWith('.yaml') || file.name.endsWith('.yml')) {
                // Simple YAML parsing (would need proper YAML library in production)
                throw new Error('YAML parsing requires additional library');
            } else {
                throw new Error('Unsupported file format');
            }
            
            // Validate hardware data structure
            if (!this.validateHardwareData(hardwareData)) {
                throw new Error('Invalid hardware data format');
            }
            
            // Process and display hardware data
            this.displayHardwareData(hardwareData);
            this.updateStatus('‚úÖ Hardware report loaded successfully', 'success');
            
            // Dispatch event for other components
            this.dispatchHardwareEvent(hardwareData);
            
        } catch (error) {
            console.error('File upload error:', error);
            this.updateStatus(`‚ùå Error processing file: ${error.message}`, 'error');
        }
    }
    
    /**
     * Test connection to local hardware detection server
     */
    async testServerConnection() {
        const serverUrl = document.getElementById('server-url').value;
        this.updateStatus('üîç Testing server connection...', 'loading');
        
        try {
            const response = await fetch(`${serverUrl}/health`, {
                method: 'GET',
                timeout: 5000
            });
            
            if (response.ok) {
                const data = await response.json();
                this.updateStatus(`‚úÖ Server connected: ${data.version || 'Unknown version'}`, 'success');
                
                // Enable hardware detection from server
                this.enableServerDetection(serverUrl);
            } else {
                throw new Error(`Server responded with status ${response.status}`);
            }
        } catch (error) {
            console.error('Server connection error:', error);
            this.updateStatus('‚ùå Could not connect to server. Make sure lx-hw-detect server is running.', 'error');
        }
    }
    
    /**
     * Enable hardware detection from server
     */
    async enableServerDetection(serverUrl) {
        const detectButton = document.createElement('button');
        detectButton.textContent = 'üîç Detect Hardware via Server';
        detectButton.className = 'primary-button';
        detectButton.onclick = () => this.detectHardwareFromServer(serverUrl);
        
        const serverUI = document.querySelector('.server-ui');
        if (serverUI) {
            serverUI.appendChild(detectButton);
        }
    }
    
    /**
     * Detect hardware from server
     */
    async detectHardwareFromServer(serverUrl) {
        this.updateStatus('üîç Detecting hardware via server...', 'loading');
        this.showProgress(0);
        
        try {
            // Start detection
            const startResponse = await fetch(`${serverUrl}/detect`, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({
                    privacy_level: 'basic',
                    output_format: 'json'
                })
            });
            
            if (!startResponse.ok) {
                throw new Error(`Detection start failed: ${startResponse.status}`);
            }
            
            const { detection_id } = await startResponse.json();
            
            // Poll for progress
            await this.pollDetectionProgress(serverUrl, detection_id);
            
        } catch (error) {
            console.error('Server detection error:', error);
            this.updateStatus(`‚ùå Server detection failed: ${error.message}`, 'error');
            this.hideProgress();
        }
    }
    
    /**
     * Poll detection progress from server
     */
    async pollDetectionProgress(serverUrl, detectionId) {
        const pollInterval = 1000; // 1 second
        const maxPolls = 60; // Maximum 60 seconds
        let polls = 0;
        
        const poll = async () => {
            if (polls >= maxPolls) {
                throw new Error('Detection timeout');
            }
            
            const response = await fetch(`${serverUrl}/detect/${detectionId}`);
            if (!response.ok) {
                throw new Error(`Poll failed: ${response.status}`);
            }
            
            const status = await response.json();
            
            if (status.status === 'completed') {
                this.displayHardwareData(status.result);
                this.updateStatus('‚úÖ Hardware detection completed', 'success');
                this.hideProgress();
                this.dispatchHardwareEvent(status.result);
                return;
            } else if (status.status === 'error') {
                throw new Error(status.error || 'Unknown error');
            } else if (status.status === 'running') {
                this.showProgress(status.progress || 0);
                this.updateStatus(`üîç ${status.message || 'Detecting hardware...'}`, 'loading');
                setTimeout(poll, pollInterval);
            }
            
            polls++;
        };
        
        await poll();
    }
    
    /**
     * Display hardware data in the interface
     */
    displayHardwareData(hardwareData) {
        const resultsContainer = document.getElementById('hardware-results');
        if (!resultsContainer) return;
        
        const deviceCount = this.countDevices(hardwareData);
        
        resultsContainer.innerHTML = `
            <div class="hardware-summary">
                <h4>üñ•Ô∏è Detected Hardware Summary</h4>
                <div class="summary-stats">
                    <div class="stat-item">
                        <span class="stat-value">${deviceCount}</span>
                        <span class="stat-label">Total Devices</span>
                    </div>
                    <div class="stat-item">
                        <span class="stat-value">${hardwareData.metadata?.privacy_level || 'Basic'}</span>
                        <span class="stat-label">Privacy Level</span>
                    </div>
                    <div class="stat-item">
                        <span class="stat-value">${this.formatDate(hardwareData.metadata?.generated_at)}</span>
                        <span class="stat-label">Generated</span>
                    </div>
                </div>
            </div>
            
            <div class="hardware-categories">
                ${this.renderHardwareCategories(hardwareData)}
            </div>
            
            <div class="hardware-actions">
                <button class="generate-config-btn primary-button">
                    ‚öôÔ∏è Generate Configuration
                </button>
                <button class="search-compatibility-btn secondary-button">
                    üîç Search Compatibility
                </button>
                <button class="export-data-btn secondary-button">
                    üì§ Export Data
                </button>
            </div>
        `;
        
        // Add action handlers
        this.setupHardwareActions(hardwareData);
    }
    
    /**
     * Render hardware categories
     */
    renderHardwareCategories(data) {
        const categories = [
            { key: 'system', name: 'üñ•Ô∏è System', data: data.system },
            { key: 'cpu', name: 'üß† CPU', data: data.cpu },
            { key: 'memory', name: 'üíæ Memory', data: data.memory },
            { key: 'graphics', name: 'üéÆ Graphics', data: data.graphics },
            { key: 'storage', name: 'üíø Storage', data: data.storage },
            { key: 'network', name: 'üåê Network', data: data.network },
            { key: 'audio', name: 'üîä Audio', data: data.audio },
            { key: 'usb', name: 'üîå USB', data: data.usb }
        ];
        
        return categories.map(category => {
            if (!category.data) return '';
            
            const count = Array.isArray(category.data) ? category.data.length : 1;
            
            return `
                <div class="hardware-category" data-category="${category.key}">
                    <div class="category-header">
                        <h5>${category.name}</h5>
                        <span class="device-count">${count} device${count !== 1 ? 's' : ''}</span>
                    </div>
                    <div class="category-devices">
                        ${this.renderCategoryDevices(category.data)}
                    </div>
                </div>
            `;
        }).join('');
    }
    
    /**
     * Render devices within a category
     */
    renderCategoryDevices(devices) {
        if (!devices) return '<p class="no-devices">No devices detected</p>';
        
        if (!Array.isArray(devices)) {
            devices = [devices];
        }
        
        return devices.map(device => `
            <div class="device-item">
                <div class="device-name">${device.model || device.name || 'Unknown Device'}</div>
                <div class="device-details">
                    ${device.vendor ? `<span class="detail">Vendor: ${device.vendor}</span>` : ''}
                    ${device.driver ? `<span class="detail">Driver: ${device.driver}</span>` : ''}
                </div>
            </div>
        `).join('');
    }
    
    /**
     * Set up hardware action handlers
     */
    setupHardwareActions(hardwareData) {
        document.querySelector('.generate-config-btn')?.addEventListener('click', () => {
            this.generateConfiguration(hardwareData);
        });
        
        document.querySelector('.search-compatibility-btn')?.addEventListener('click', () => {
            this.searchCompatibility(hardwareData);
        });
        
        document.querySelector('.export-data-btn')?.addEventListener('click', () => {
            this.exportData(hardwareData);
        });
    }
    
    /**
     * Generate configuration recommendations
     */
    generateConfiguration(hardwareData) {
        // Integration with existing configuration engine
        if (window.configEngine) {
            window.configEngine.loadHardwareData(hardwareData);
            window.configEngine.generateRecommendations();
        } else {
            // Fallback: Show configuration modal
            this.showConfigurationModal(hardwareData);
        }
    }
    
    /**
     * Search for compatibility information
     */
    searchCompatibility(hardwareData) {
        // Integration with existing search engine
        if (window.searchEngine) {
            const devices = this.extractDeviceNames(hardwareData);
            window.searchEngine.searchMultipleDevices(devices);
        }
    }
    
    /**
     * Export hardware data
     */
    exportData(hardwareData) {
        const dataStr = JSON.stringify(hardwareData, null, 2);
        const blob = new Blob([dataStr], { type: 'application/json' });
        const url = URL.createObjectURL(blob);
        
        const a = document.createElement('a');
        a.href = url;
        a.download = `hardware-report-${new Date().toISOString().split('T')[0]}.json`;
        a.click();
        
        URL.revokeObjectURL(url);
    }
    
    /**
     * Dispatch hardware detection event for other components
     */
    dispatchHardwareEvent(hardwareData) {
        const event = new CustomEvent('hardwareDetected', {
            detail: {
                source: 'hardware-bridge',
                data: hardwareData,
                timestamp: new Date().toISOString()
            }
        });
        
        document.dispatchEvent(event);
    }
    
    /**
     * Utility methods
     */
    checkLocalServer() {
        // Check if local server detection is available
        return 'fetch' in window;
    }
    
    checkCliIntegration() {
        // Check if CLI integration is available (requires File System Access API)
        return 'showOpenFilePicker' in window;
    }
    
    validateHardwareData(data) {
        // Basic validation of hardware data structure
        return data && typeof data === 'object' && 
               (data.system || data.cpu || data.graphics || data.storage);
    }
    
    countDevices(data) {
        let count = 0;
        if (data.system) count++;
        if (data.cpu) count++;
        if (data.memory) count++;
        if (data.graphics) count += data.graphics.length || 0;
        if (data.storage) count += data.storage.length || 0;
        if (data.network) count += data.network.length || 0;
        if (data.audio) count += data.audio.length || 0;
        if (data.usb) count += data.usb.length || 0;
        return count;
    }
    
    extractDeviceNames(data) {
        const names = [];
        if (data.cpu?.model) names.push(data.cpu.model);
        if (data.graphics) data.graphics.forEach(g => g.model && names.push(g.model));
        if (data.storage) data.storage.forEach(s => s.model && names.push(s.model));
        if (data.network) data.network.forEach(n => n.model && names.push(n.model));
        return names;
    }
    
    formatDate(dateString) {
        if (!dateString) return 'Unknown';
        return new Date(dateString).toLocaleDateString();
    }
    
    updateStatus(message, type) {
        const statusEl = document.getElementById('detection-status');
        if (statusEl) {
            statusEl.textContent = message;
            statusEl.className = `status-message ${type}`;
        }
    }
    
    showProgress(percent) {
        const progressEl = document.getElementById('detection-progress');
        const fillEl = progressEl?.querySelector('.progress-fill');
        
        if (progressEl && fillEl) {
            progressEl.style.display = 'block';
            fillEl.style.width = `${percent}%`;
        }
    }
    
    hideProgress() {
        const progressEl = document.getElementById('detection-progress');
        if (progressEl) {
            progressEl.style.display = 'none';
        }
    }
    
    setupDragAndDrop() {
        const dropzone = document.querySelector('.upload-dropzone');
        if (!dropzone) return;
        
        ['dragenter', 'dragover', 'dragleave', 'drop'].forEach(eventName => {
            dropzone.addEventListener(eventName, preventDefaults, false);
        });
        
        ['dragenter', 'dragover'].forEach(eventName => {
            dropzone.addEventListener(eventName, highlight, false);
        });
        
        ['dragleave', 'drop'].forEach(eventName => {
            dropzone.addEventListener(eventName, unhighlight, false);
        });
        
        dropzone.addEventListener('drop', handleDrop, false);
        
        function preventDefaults(e) {
            e.preventDefault();
            e.stopPropagation();
        }
        
        function highlight() {
            dropzone.classList.add('drag-over');
        }
        
        function unhighlight() {
            dropzone.classList.remove('drag-over');
        }
        
        const self = this;
        function handleDrop(e) {
            const files = e.dataTransfer.files;
            if (files.length > 0) {
                self.handleFileUpload(files[0]);
            }
        }
    }
    
    /**
     * Authenticate with GitHub using the global GitHub auth system
     */
    authenticateWithGitHub() {
        if (window.githubAuth) {
            window.githubAuth.initiateLogin();
            
            // Listen for auth completion
            const checkAuth = setInterval(() => {
                if (window.githubAuth.isAuthenticated) {
                    clearInterval(checkAuth);
                    this.updateGitHubStatus();
                }
            }, 1000);
        } else {
            console.error('GitHub authentication system not available');
            this.showStatus('GitHub authentication system not loaded', 'error');
        }
    }
    
    /**
     * Submit hardware data as GitHub issue
     */
    async submitGitHubIssue() {
        if (!window.githubAuth || !window.githubAuth.isAuthenticated) {
            this.showStatus('Please authenticate with GitHub first', 'error');
            return;
        }
        
        const hardwareData = this.getHardwareData();
        if (!hardwareData) {
            this.showStatus('Please upload or detect hardware data first', 'error');
            return;
        }
        
        try {
            this.showStatus('Submitting hardware report as GitHub issue...', 'info');
            const issue = await window.githubAuth.createHardwareIssue(hardwareData);
            this.showStatus(`Successfully created GitHub issue #${issue.number}`, 'success');
        } catch (error) {
            console.error('Failed to create GitHub issue:', error);
            this.showStatus(`Failed to create GitHub issue: ${error.message}`, 'error');
        }
    }
    
    /**
     * Create GitHub pull request with hardware data
     */
    async createGitHubPullRequest() {
        if (!window.githubAuth || !window.githubAuth.isAuthenticated) {
            this.showStatus('Please authenticate with GitHub first', 'error');
            return;
        }
        
        const hardwareData = this.getHardwareData();
        if (!hardwareData) {
            this.showStatus('Please upload or detect hardware data first', 'error');
            return;
        }
        
        try {
            this.showStatus('Creating pull request with hardware data...', 'info');
            const pr = await window.githubAuth.createHardwarePullRequest(hardwareData);
            this.showStatus(`Successfully created pull request #${pr.number}`, 'success');
        } catch (error) {
            console.error('Failed to create pull request:', error);
            this.showStatus(`Failed to create pull request: ${error.message}`, 'error');
        }
    }
    
    /**
     * Update GitHub authentication status in the UI
     */
    updateGitHubStatus() {
        const statusEl = document.getElementById('github-user-status');
        const issueBtn = document.getElementById('submit-github-issue');
        const prBtn = document.getElementById('create-pull-request');
        const authBtn = document.getElementById('github-auth-btn');
        
        if (window.githubAuth && window.githubAuth.isAuthenticated) {
            const userInfo = window.githubAuth.userInfo;
            if (statusEl) {
                statusEl.innerHTML = `‚úÖ Authenticated as <strong>${userInfo.login}</strong>`;
            }
            if (issueBtn) issueBtn.disabled = false;
            if (prBtn) prBtn.disabled = false;
            if (authBtn) authBtn.textContent = 'üîì Logout from GitHub';
        } else {
            if (statusEl) {
                statusEl.textContent = 'üîí GitHub authentication required for community contributions';
            }
            if (issueBtn) issueBtn.disabled = true;
            if (prBtn) prBtn.disabled = true;
            if (authBtn) authBtn.textContent = 'üîê Login to GitHub';
        }
    }
    
    /**
     * Get current hardware data from bridge
     */
    getHardwareData() {
        // Try to get hardware data from different sources
        if (this.currentHardwareData) {
            return this.currentHardwareData;
        }
        
        // Try to get from configuration engine if available
        if (window.configEngine && window.configEngine.currentHardware) {
            return window.configEngine.currentHardware;
        }
        
        // Return sample data for demonstration
        return window.sampleHardwareData || null;
    }
    
    /**
     * Show status message in the bridge interface
     */
    showStatus(message, type = 'info') {
        const statusEl = document.getElementById('detection-status');
        if (statusEl) {
            statusEl.textContent = message;
            statusEl.className = `status-message status-${type}`;
        }
        
        // Also use global notification system if available
        if (window.githubAuth) {
            window.githubAuth.showNotification(message, type);
        }
    }
    
    /**
     * Copy command to clipboard and provide user feedback
     */
    async copyCommandToClipboard(command, buttonElement) {
        try {
            await navigator.clipboard.writeText(command);
            
            // Provide visual feedback
            const originalText = buttonElement.textContent;
            buttonElement.textContent = '‚úÖ Copied!';
            buttonElement.classList.add('copied');
            
            setTimeout(() => {
                buttonElement.textContent = originalText;
                buttonElement.classList.remove('copied');
            }, 2000);
            
            console.log('Command copied to clipboard:', command);
        } catch (err) {
            // Fallback for older browsers
            this.fallbackCopyCommand(command, buttonElement);
        }
    }
    
    /**
     * Fallback copy method for browsers without clipboard API
     */
    fallbackCopyCommand(command, buttonElement) {
        const textArea = document.createElement('textarea');
        textArea.value = command;
        textArea.style.position = 'fixed';
        textArea.style.left = '-999999px';
        textArea.style.top = '-999999px';
        document.body.appendChild(textArea);
        textArea.focus();
        textArea.select();
        
        try {
            document.execCommand('copy');
            
            // Provide visual feedback
            const originalText = buttonElement.textContent;
            buttonElement.textContent = '‚úÖ Copied!';
            buttonElement.classList.add('copied');
            
            setTimeout(() => {
                buttonElement.textContent = originalText;
                buttonElement.classList.remove('copied');
            }, 2000);
            
            console.log('Command copied to clipboard (fallback):', command);
        } catch (err) {
            console.error('Could not copy command to clipboard:', err);
            buttonElement.textContent = '‚ùå Copy Failed';
            setTimeout(() => {
                buttonElement.textContent = 'üìã Copy';
            }, 2000);
        } finally {
            document.body.removeChild(textArea);
        }
    }
    
    checkAvailableMethods() {
        // Update method availability based on current capabilities
        this.detectionMethods['local-server'].available = this.checkLocalServer();
        this.detectionMethods['cli-integration'].available = this.checkCliIntegration();
        
        // Re-render if needed
        const methodsContainer = document.querySelector('.detection-methods');
        if (methodsContainer) {
            methodsContainer.innerHTML = this.renderDetectionMethods();
        }
    }
}

// Auto-initialize when DOM is ready
document.addEventListener('DOMContentLoaded', () => {
    window.hardwareBridge = new HardwareBridge();
});

// Make available globally
window.HardwareBridge = HardwareBridge;