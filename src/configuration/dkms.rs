use std::collections::HashMap;
use crate::configuration::*;
use crate::hardware::HardwareReport;
use crate::errors::LxHwError;

pub struct DkmsManager {
    module_database: HashMap<String, DkmsModuleInfo>,
    hardware_module_mappings: HashMap<String, Vec<String>>,
    distribution_support: HashMap<String, DistributionDkmsConfig>,
}

#[derive(Debug, Clone)]
pub struct DkmsModuleInfo {
    pub module_name: String,
    pub version: String,
    pub source_type: DkmsSourceType,
    pub build_dependencies: Vec<String>,
    pub supported_kernels: Vec<KernelVersionRange>,
    pub hardware_compatibility: Vec<HardwarePattern>,
    pub installation_instructions: Vec<InstallationStep>,
    pub configuration_files: Vec<String>,
    pub known_issues: Vec<String>,
    pub alternatives: Vec<String>,
}

#[derive(Debug, Clone)]
pub enum DkmsSourceType {
    GitHub { url: String, branch: String },
    SourceForge { url: String },
    DistributionPackage { package_name: String },
    OfficialWebsite { url: String },
    Custom { instructions: String },
}

#[derive(Debug, Clone)]
pub struct KernelVersionRange {
    pub min_version: String,
    pub max_version: Option<String>,
    pub architecture: Option<String>,
}

#[derive(Debug, Clone)]
pub struct HardwarePattern {
    pub vendor_id: Option<String>,
    pub device_id: Option<String>,
    pub subsystem_vendor: Option<String>,
    pub subsystem_device: Option<String>,
    pub device_class: Option<String>,
}

#[derive(Debug, Clone)]
pub struct InstallationStep {
    pub step_number: u8,
    pub command: String,
    pub description: String,
    pub required_privileges: PrivilegeLevel,
    pub expected_output: Option<String>,
    pub error_recovery: Option<String>,
}

#[derive(Debug, Clone)]
pub enum PrivilegeLevel {
    User,
    Root,
    Sudo,
}

#[derive(Debug, Clone)]
pub struct DistributionDkmsConfig {
    pub distribution_name: String,
    pub dkms_package_name: String,
    pub kernel_headers_package: String,
    pub build_essential_packages: Vec<String>,
    pub dkms_config_path: String,
}

impl DkmsManager {
    pub fn new() -> Result<Self, LxHwError> {
        let mut manager = Self {
            module_database: HashMap::new(),
            hardware_module_mappings: HashMap::new(),
            distribution_support: HashMap::new(),
        };

        manager.initialize_module_database()?;
        manager.initialize_hardware_mappings()?;
        manager.initialize_distribution_support()?;

        Ok(manager)
    }

    pub fn identify_required_modules(&self, hardware: &HardwareReport) -> Result<Vec<DkmsModule>, LxHwError> {
        let mut required_modules = Vec::new();

        // Check graphics hardware for proprietary drivers
        for gpu in &hardware.graphics {
            if let Some(modules) = self.identify_gpu_dkms_modules(gpu)? {
                required_modules.extend(modules);
            }
        }

        // Check network hardware for proprietary drivers
        for network in &hardware.network {
            if let Some(modules) = self.identify_network_dkms_modules(network)? {
                required_modules.extend(modules);
            }
        }

        // Check for specialized hardware in kernel support details
        if let Some(kernel_support) = &hardware.kernel_support {
            for device in &kernel_support.device_support_details {
                if let Some(modules) = self.identify_device_dkms_modules(device)? {
                    required_modules.extend(modules);
                }
            }
        }

        Ok(required_modules)
    }

    pub fn generate_installation_script(&self, modules: &[DkmsModule], distribution: &str) -> Result<String, LxHwError> {
        let mut script = String::new();
        
        script.push_str("#!/bin/bash\n");
        script.push_str("# DKMS Module Installation Script\n");
        script.push_str("# Generated by lx-hw-db Configuration Engine\n\n");
        script.push_str("set -e\n\n");

        // Add distribution-specific setup
        if let Some(dist_config) = self.distribution_support.get(distribution) {
            script.push_str("# Install DKMS and build dependencies\n");
            script.push_str(&format!("echo 'Installing DKMS and build dependencies for {}'...\n", distribution));
            
            let install_cmd = self.get_package_install_command(distribution)?;
            script.push_str(&format!("{} {}", install_cmd, dist_config.dkms_package_name));
            script.push_str(&format!(" {}", dist_config.kernel_headers_package));
            
            for dep in &dist_config.build_essential_packages {
                script.push_str(&format!(" {}", dep));
            }
            script.push_str("\n\n");
        }

        // Generate installation commands for each module
        for module in modules {
            script.push_str(&format!("# Installing DKMS module: {}\n", module.module_name));
            script.push_str(&format!("echo 'Installing {} version {}'...\n", module.module_name, module.version));
            
            // Get installation steps from module database
            if let Some(module_info) = self.module_database.get(&module.module_name) {
                for step in &module_info.installation_instructions {
                script.push_str(&format!("# Step {}: {}\n", step.step_number, step.description));
                
                // Add privilege escalation if needed
                match step.required_privileges {
                    PrivilegeLevel::Root => script.push_str("sudo "),
                    PrivilegeLevel::Sudo => script.push_str("sudo "),
                    PrivilegeLevel::User => {},
                }
                
                script.push_str(&step.command);
                script.push_str("\n");
                
                if let Some(expected_output) = &step.expected_output {
                    script.push_str(&format!("# Expected output: {}\n", expected_output));
                }
                
                script.push_str("\n");
                }
            } else {
                // Fallback to basic installation if module not in database
                script.push_str("# Module not found in database, attempting basic installation\n");
                for (i, step) in module.installation_steps.iter().enumerate() {
                    script.push_str(&format!("# Step {}: Manual installation step\n", i + 1));
                    script.push_str(&format!("{}\n", step));
                }
            }
            
            // Add module verification
            script.push_str(&format!("# Verify {} installation\n", module.module_name));
            script.push_str(&format!("dkms status {} || echo 'Warning: {} DKMS status check failed'\n", module.module_name, module.module_name));
            script.push_str("\n");
        }

        script.push_str("echo 'DKMS module installation completed!'\n");
        script.push_str("echo 'Please reboot to ensure all modules are loaded properly.'\n");

        Ok(script)
    }

    fn initialize_module_database(&mut self) -> Result<(), LxHwError> {
        // NVIDIA Driver DKMS module
        self.module_database.insert("nvidia".to_string(), DkmsModuleInfo {
            module_name: "nvidia".to_string(),
            version: "525.147.05".to_string(),
            source_type: DkmsSourceType::DistributionPackage {
                package_name: "nvidia-dkms".to_string(),
            },
            build_dependencies: vec![
                "build-essential".to_string(),
                "dkms".to_string(),
                "linux-headers-generic".to_string(),
            ],
            supported_kernels: vec![
                KernelVersionRange {
                    min_version: "5.4".to_string(),
                    max_version: Some("6.8".to_string()),
                    architecture: Some("x86_64".to_string()),
                },
            ],
            hardware_compatibility: vec![
                HardwarePattern {
                    vendor_id: Some("10de".to_string()), // NVIDIA
                    device_id: None,
                    subsystem_vendor: None,
                    subsystem_device: None,
                    device_class: Some("0300".to_string()), // VGA controller
                },
            ],
            installation_instructions: vec![
                InstallationStep {
                    step_number: 1,
                    command: "apt update && apt install -y nvidia-dkms".to_string(),
                    description: "Install NVIDIA DKMS package".to_string(),
                    required_privileges: PrivilegeLevel::Root,
                    expected_output: Some("NVIDIA kernel module will be compiled".to_string()),
                    error_recovery: Some("Check kernel headers are installed".to_string()),
                },
                InstallationStep {
                    step_number: 2,
                    command: "dkms autoinstall".to_string(),
                    description: "Rebuild NVIDIA modules for current kernel".to_string(),
                    required_privileges: PrivilegeLevel::Root,
                    expected_output: Some("Module nvidia built successfully".to_string()),
                    error_recovery: Some("Check build dependencies and kernel version compatibility".to_string()),
                },
            ],
            configuration_files: vec![
                "/etc/modprobe.d/blacklist-nouveau.conf".to_string(),
                "/etc/X11/xorg.conf".to_string(),
            ],
            known_issues: vec![
                "Conflicts with nouveau driver".to_string(),
                "May not work with latest kernel versions immediately".to_string(),
                "Requires secure boot to be disabled or custom signing".to_string(),
            ],
            alternatives: vec!["nouveau".to_string()],
        });

        // Broadcom WiFi Driver
        self.module_database.insert("wl".to_string(), DkmsModuleInfo {
            module_name: "wl".to_string(),
            version: "6.30.223.271".to_string(),
            source_type: DkmsSourceType::DistributionPackage {
                package_name: "broadcom-sta-dkms".to_string(),
            },
            build_dependencies: vec![
                "build-essential".to_string(),
                "dkms".to_string(),
                "linux-headers-generic".to_string(),
            ],
            supported_kernels: vec![
                KernelVersionRange {
                    min_version: "4.19".to_string(),
                    max_version: Some("6.5".to_string()),
                    architecture: Some("x86_64".to_string()),
                },
            ],
            hardware_compatibility: vec![
                HardwarePattern {
                    vendor_id: Some("14e4".to_string()), // Broadcom
                    device_id: None,
                    subsystem_vendor: None,
                    subsystem_device: None,
                    device_class: Some("0280".to_string()), // Network controller
                },
            ],
            installation_instructions: vec![
                InstallationStep {
                    step_number: 1,
                    command: "apt update && apt install -y broadcom-sta-dkms".to_string(),
                    description: "Install Broadcom STA DKMS package".to_string(),
                    required_privileges: PrivilegeLevel::Root,
                    expected_output: Some("Broadcom STA kernel module will be compiled".to_string()),
                    error_recovery: Some("Remove conflicting b43/ssb modules first".to_string()),
                },
                InstallationStep {
                    step_number: 2,
                    command: "modprobe -r b43 ssb wl && modprobe wl".to_string(),
                    description: "Remove conflicting modules and load wl driver".to_string(),
                    required_privileges: PrivilegeLevel::Root,
                    expected_output: Some("wl module loaded successfully".to_string()),
                    error_recovery: Some("Check dmesg for error messages".to_string()),
                },
            ],
            configuration_files: vec![
                "/etc/modprobe.d/blacklist-broadcom.conf".to_string(),
            ],
            known_issues: vec![
                "Conflicts with open-source b43 driver".to_string(),
                "May require manual module loading after kernel updates".to_string(),
            ],
            alternatives: vec!["b43".to_string(), "brcmfmac".to_string()],
        });

        // VirtualBox modules
        self.module_database.insert("vboxdrv".to_string(), DkmsModuleInfo {
            module_name: "vboxdrv".to_string(),
            version: "7.0".to_string(),
            source_type: DkmsSourceType::DistributionPackage {
                package_name: "virtualbox-dkms".to_string(),
            },
            build_dependencies: vec![
                "build-essential".to_string(),
                "dkms".to_string(),
                "linux-headers-generic".to_string(),
                "gcc".to_string(),
                "make".to_string(),
            ],
            supported_kernels: vec![
                KernelVersionRange {
                    min_version: "4.19".to_string(),
                    max_version: None,
                    architecture: None,
                },
            ],
            hardware_compatibility: vec![], // Software-only, no specific hardware requirements
            installation_instructions: vec![
                InstallationStep {
                    step_number: 1,
                    command: "apt update && apt install -y virtualbox virtualbox-dkms".to_string(),
                    description: "Install VirtualBox and DKMS modules".to_string(),
                    required_privileges: PrivilegeLevel::Root,
                    expected_output: Some("VirtualBox kernel modules will be compiled".to_string()),
                    error_recovery: Some("Ensure kernel headers match running kernel version".to_string()),
                },
                InstallationStep {
                    step_number: 2,
                    command: "/sbin/vboxconfig".to_string(),
                    description: "Configure VirtualBox kernel modules".to_string(),
                    required_privileges: PrivilegeLevel::Root,
                    expected_output: Some("VirtualBox kernel modules configured successfully".to_string()),
                    error_recovery: Some("Check secure boot settings and module signing".to_string()),
                },
            ],
            configuration_files: vec![],
            known_issues: vec![
                "May require secure boot to be disabled".to_string(),
                "Needs rebuild after kernel updates".to_string(),
            ],
            alternatives: vec!["kvm".to_string(), "qemu".to_string()],
        });

        Ok(())
    }

    fn initialize_hardware_mappings(&mut self) -> Result<(), LxHwError> {
        // Map NVIDIA GPUs to nvidia DKMS module
        self.hardware_module_mappings.insert("10de".to_string(), vec!["nvidia".to_string()]);
        
        // Map Broadcom network devices to wl module
        self.hardware_module_mappings.insert("14e4".to_string(), vec!["wl".to_string()]);
        
        Ok(())
    }

    fn initialize_distribution_support(&mut self) -> Result<(), LxHwError> {
        self.distribution_support.insert("Ubuntu".to_string(), DistributionDkmsConfig {
            distribution_name: "Ubuntu".to_string(),
            dkms_package_name: "dkms".to_string(),
            kernel_headers_package: "linux-headers-$(uname -r)".to_string(),
            build_essential_packages: vec![
                "build-essential".to_string(),
                "gcc".to_string(),
                "make".to_string(),
            ],
            dkms_config_path: "/etc/dkms".to_string(),
        });

        self.distribution_support.insert("Debian".to_string(), DistributionDkmsConfig {
            distribution_name: "Debian".to_string(),
            dkms_package_name: "dkms".to_string(),
            kernel_headers_package: "linux-headers-$(uname -r)".to_string(),
            build_essential_packages: vec![
                "build-essential".to_string(),
                "gcc".to_string(),
                "make".to_string(),
            ],
            dkms_config_path: "/etc/dkms".to_string(),
        });

        self.distribution_support.insert("Fedora".to_string(), DistributionDkmsConfig {
            distribution_name: "Fedora".to_string(),
            dkms_package_name: "dkms".to_string(),
            kernel_headers_package: "kernel-headers-$(uname -r)".to_string(),
            build_essential_packages: vec![
                "gcc".to_string(),
                "gcc-c++".to_string(),
                "make".to_string(),
                "kernel-devel".to_string(),
            ],
            dkms_config_path: "/etc/dkms".to_string(),
        });

        self.distribution_support.insert("Arch Linux".to_string(), DistributionDkmsConfig {
            distribution_name: "Arch Linux".to_string(),
            dkms_package_name: "dkms".to_string(),
            kernel_headers_package: "linux-headers".to_string(),
            build_essential_packages: vec![
                "base-devel".to_string(),
                "gcc".to_string(),
                "make".to_string(),
            ],
            dkms_config_path: "/etc/dkms".to_string(),
        });

        Ok(())
    }

    fn identify_gpu_dkms_modules(&self, gpu_info: &crate::hardware::GraphicsDevice) -> Result<Option<Vec<DkmsModule>>, LxHwError> {
        let vendor = &gpu_info.vendor;
        let vendor_lower = vendor.to_lowercase();

        if vendor_lower.contains("nvidia") {
            // Check if proprietary driver would be beneficial
            if let Some(nvidia_module) = self.module_database.get("nvidia") {
                let dkms_module = DkmsModule {
                    module_name: nvidia_module.module_name.clone(),
                    version: nvidia_module.version.clone(),
                    source_url: "https://developer.nvidia.com/cuda-downloads".to_string(),
                    build_dependencies: nvidia_module.build_dependencies.clone(),
                    kernel_versions: nvidia_module.supported_kernels.iter()
                        .map(|k| format!("{}-{}", k.min_version, k.max_version.as_ref().unwrap_or(&"latest".to_string())))
                        .collect(),
                    installation_steps: nvidia_module.installation_instructions.iter()
                        .map(|step| step.command.clone())
                        .collect(),
                    auto_rebuild: true,
                };

                return Ok(Some(vec![dkms_module]));
            }
        }

        Ok(None)
    }

    fn identify_network_dkms_modules(&self, network_info: &crate::hardware::NetworkDevice) -> Result<Option<Vec<DkmsModule>>, LxHwError> {
        let vendor = &network_info.vendor;
        let product = &network_info.model;
        
        let vendor_lower = vendor.to_lowercase();
        let product_lower = product.to_lowercase();

        // Check for Broadcom WiFi devices
        if vendor_lower.contains("broadcom") && (product_lower.contains("wireless") || product_lower.contains("wifi")) {
            if let Some(wl_module) = self.module_database.get("wl") {
                let dkms_module = DkmsModule {
                    module_name: wl_module.module_name.clone(),
                    version: wl_module.version.clone(),
                    source_url: "https://www.broadcom.com/support/download-search".to_string(),
                    build_dependencies: wl_module.build_dependencies.clone(),
                    kernel_versions: wl_module.supported_kernels.iter()
                        .map(|k| format!("{}-{}", k.min_version, k.max_version.as_ref().unwrap_or(&"latest".to_string())))
                        .collect(),
                    installation_steps: wl_module.installation_instructions.iter()
                        .map(|step| step.command.clone())
                        .collect(),
                    auto_rebuild: true,
                };

                return Ok(Some(vec![dkms_module]));
            }
        }

        Ok(None)
    }

    fn identify_device_dkms_modules(&self, _device: &crate::hardware::DeviceCompatibility) -> Result<Option<Vec<DkmsModule>>, LxHwError> {
        // For now, we'll implement this as a placeholder
        // In a real implementation, this would check device details against the DKMS module database
        Ok(None)
    }

    fn get_package_install_command(&self, distribution: &str) -> Result<String, LxHwError> {
        match distribution.to_lowercase().as_str() {
            "ubuntu" | "debian" => Ok("apt update && apt install -y".to_string()),
            "fedora" => Ok("dnf install -y".to_string()),
            "centos" | "rhel" => Ok("yum install -y".to_string()),
            "arch" | "arch linux" => Ok("pacman -S --noconfirm".to_string()),
            "opensuse" | "suse" => Ok("zypper install -y".to_string()),
            "gentoo" => Ok("emerge".to_string()),
            _ => Ok("# Please install manually:".to_string()),
        }
    }
}